## 유형 정리

### BFS
- 주 유형 : 최단거리
- N 범위 크면 BFS
- 다익스트라 알고리즘 고려

### DFS
- 전체 탐색 (전체 거리 측정 하기) 백트래킹
- 검색 속도는 BFS(너비 우선 탐색)에 비해 느리다.
- 백 트래킹에 사용되는 알고리즘
- 0~100 (DFS) N범위 작은 것
- 모든경우의 수 검색시

### BFS/DFS 주의할점
- maps y랑 x위치 헷갈리지 않게.
- maps 좌표 최초 검사 (<0 or >N) 후에 맵 값 Check

### 최단 경로(다익스트라 vs 플로이드 워셜)
- 다익스트라 (그리디)
    - 다익스트라는 단계마다 최단 거리를 가지는 노드를 매번 찾음
- 플로이드 워셜(DP)
    - 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구할 때 
    - **노드가 적을 때 사용하면 쉽게 해결**
    - 플로이드는 거쳐가는 노드를 기준으로 최소 비용을 선택 

### 최소 신장트리(kruskal vs 위상 정렬)
- Kruskal (최소 신장트리)
    - 모든 노드를 지나는데의 최소 거리
    - 가장 거리가 짧은 간선부터 차례대로 집합에 추가 + 사이클을 발생시키는 간선은 제외하고 연결

### 최단경로 (BFS vs 다익스트라 vs 플로이드워셜 vs 벨만포드 vs A*)
- BFS
    - 가중치가 없거나 모든 가중치가 동일한 그래프에서 최단경로를 구하는 경우 가장 빠르다                                       
- 다익스트라 (Dijkstra)
    - 음이 아닌 가중 그래프에서의 단일 쌍, 단일 출발, 단일 도착 최단 경로 문제 
    - 한 점에서 다른 점들로 가는 최소거리
- 플로이드-워셜(Floyd-Warshall)
    - 전체 쌍 최단 경로 문제, 다수출발, 단일도착                                                                                            
- 벨만-포드(Bellman-Ford-Moore)
    - 가중 그래프에서의 단일 쌍, 단일 출발, 단일 도착 최단 경로 문제                                                                            
- A*알고리즘
    - 하나의 정점에서부터 다른 하나의 정점까지의 최단 경로를 구하는 경우
    
### 구현 (브루트 포스 vs 시뮬레이션)
- 완전 탐색(브루트 포스, Brute force)
    - 모든 경우의 수를 계산하는 방법을 의미
    - 탐색해야 할 전체 데이터의 개수가 100만 개 이하일 때 완전 탐색을 사용하면 적절

- 시뮬레이션
    - 문제에서 제시한 알고리즘을 한단계씩 차례대로 직접 수행해야하는 문제유형을 의미

### heapq (우선순위큐, 최소힙)
- 데이터의 갯수가 N일 때, 힙 자료구조에 N개의 데이터를 모두 넣은 뒤 모든 데이터를 꺼내는 작업 진행시
- 삽입할 때는 O(logN)의 연산 N번 반복 => O(N logN)
- 삭제할 때도 O(logN)의 연산 N번 반복 => O(N logN)
- 우선순위에 맞게 빠르게 뽑아 낼 수 있어 힙은 '우선순위 큐'를 구현하는데 가장 많이 사용
- 첫번째 원소인 '거리' 정보를 기준으로 우선순위 큐를 구성하므로 거리가 짧은 원소가 항상 먼저 나옴
